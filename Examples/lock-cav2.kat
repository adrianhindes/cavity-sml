#-----------------------------------------------------------------------
# lock-cav2.kat test file for Finesse 1.1
# 
# Example for locking a Fabry-Perot cavity with FINESSE
# with a normalised error signal
#
# http://www.gwoptics.org/finesse/ 
# 01.11.2013
# 								  
# The "#" is used for comment lines. 				  
#
#                                                        
#                        m1                               m2           
#         .-----.       .-.                               .-.          
#         |     |       | |      . . . . . . . . . .      | |          
# --> n1  | EOM | n2 n3 | |  n4  .      s_cav      .  n5  | | 
#         |     |       | |      . . . . . . . . . .      | |          
#         `-----'       | |                               | |          
#                       `-'                               `-'          
#------------------------------------------------------------------

l i1 1 0 n0                 # laser P=1W f_offset=0Hz
s s0 1 n0 n1
mod eo1 40k 0.3 3 pm n1 n2  # phase modulator f_mod=40kHz
                            # midx=0.3 order=3 
s s1 1 n2 n3
                            # a Fabry-Perot cavity
m m1 0.9 0.0001 0 n3 n4     # mirror R=0.9 T=0.0001 phi=0
s s_cav 1200 n4 n5          # space L=1200
m m2 0.9 0.1 0 n5 n6        # mirror R=0.8 T=0.1 phi=0
attr m2 Rc 1400             # ROC for m2 = 1400m

cav cavity1 m1 n4 m2 n5     # compute cavity eigenmodes
maxtem 3                    # TEM modes up to n+m=3
time                        # print computation time

###### locking the cavity ############
#
# The cavity is locked with the Pound-Drever-Hall
# technique, the feedback is connected to m1.
# The resulting plot contains only the feedback
# signal of the control loop.

pd1 pdh 40k 0 n3                # diode for PDH signal
noplot pdh                      # do not plot this output

pd power n4                     # transmitted power
noplot power                    # do not plot this output

# define error signal 'err'= Re(photo diode output)
set err pdh re                  
# define normalisation signal 'p' = transmitted power
set p power re
# compute y = normalised error signal 
func y = $err/(1000*$p+0.0000001)
noplot y                        # do not plot this output
# define control loop:
# output : feedback signal = $z
# input  : error signal = $y
# parameters:
# - loop gain = -10000
# - 'accuracy' threshold for error signal = 100n
lock z $y -10k 100n 

# connect the feedback to the input mirror:
put* m1 phi $z                  # add $z to the m1 tuning

#
#######################################

xaxis m2 xbeta lin 0 10u 10     # tune the angle of m2 

yaxis abs 


 
